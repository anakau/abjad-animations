<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Implode</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #280833; overflow-x: hidden; }
    #scroll-container { height: 500vh; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="scroll-container"></div>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const ctx    = canvas.getContext('2d');
    let W, H, CX, CY;

    function setSize() {
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      CX = W / 2; CY = H / 2;
    }
    setSize();

    const TEXT    = 'Bringing Clarity to Complexity';
    const DOT_CLR = '#B21EE3';
    const NUM     = 280;

    // ── Particles ───────────────────────────────────────────────────────────
    let particles = [];
    function initParticles() {
      particles = [];
      for (let i = 0; i < NUM; i++) {
        particles.push({
          x:    Math.random() * W,
          y:    Math.random() * H,
          vx:   (Math.random() - 0.5) * 2.5,
          vy:   (Math.random() - 0.5) * 2.5,
          len:  Math.random() * 14 + 8,  // slash length [8, 22]
          lw:   Math.random() * 1.5 + 0.8, // line width [0.8, 2.3]
          node: i % 2,                   // 0 = left node, 1 = right node
          sx:   0, sy: 0                 // implode-start snapshot
        });
      }
    }
    initParticles();

    // ── Scroll ──────────────────────────────────────────────────────────────
    let scrollProg = 0;
    window.addEventListener('scroll', () => {
      const max  = document.body.scrollHeight - window.innerHeight;
      scrollProg = Math.min(1, window.scrollY / (max * 0.85));
    });

    const ease  = t => t < 0.5 ? 2*t*t : -1 + (4-2*t)*t;
    const lerp  = (a, b, t) => a + (b - a) * t;
    const clamp = (t, a = 0, b = 1) => Math.max(a, Math.min(b, t));
    const sub   = (t, a, b) => clamp((t - a) / (b - a));

    // Phase milestones
    const PH = {
      floatEnd:   0.32,
      implodeEnd: 0.56,
      collide:    0.70,  // nodes reach center
      bounceEnd:  0.76,  // rebound settles → text starts here
      sepEnd:     0.94,  // nodes at edges → text fully revealed
    };

    let snapped = false;

    // ── Render ──────────────────────────────────────────────────────────────
    let lastTS = 0;
    function render(ts) {
      const dt = Math.min((ts - lastTS) / 16.67, 3);
      lastTS = ts;

      const prog = ease(scrollProg);

      const pImplode = sub(prog, PH.floatEnd,   PH.implodeEnd);
      const pCollide = sub(prog, PH.implodeEnd,  PH.collide);
      const pBounce  = sub(prog, PH.collide,     PH.bounceEnd);
      const pSep     = sub(prog, PH.bounceEnd,   PH.sepEnd);

      // Snapshot float positions the moment implosion begins
      if (pImplode > 0 && !snapped) {
        snapped = true;
        particles.forEach(p => { p.sx = p.x; p.sy = p.y; });
      }
      if (pImplode === 0) snapped = false;

      // Staging positions — where particles implode toward
      const stL = { x: CX - W * 0.26, y: CY };
      const stR = { x: CX + W * 0.26, y: CY };

      // Current position of each condensed node
      function nodeX(side) {
        const st   = side === 0 ? stL.x : stR.x;
        const sign = side === 0 ? -1 : 1;
        if (prog <= PH.implodeEnd) return st;
        if (prog <= PH.collide)    return lerp(st, CX, ease(pCollide));
        if (prog <= PH.bounceEnd)  return lerp(CX, CX + sign * W * 0.04, ease(pBounce));
        const rebound = CX + sign * W * 0.04;
        const edge    = side === 0 ? -W * 0.07 : W * 1.07;
        return lerp(rebound, edge, ease(pSep));
      }

      const nxL = nodeX(0);
      const nxR = nodeX(1);

      // ── CLEAR + BACKGROUND ────────────────────────────────────────────────
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#280833';
      ctx.fillRect(0, 0, W, H);

      // ── 1. Particles (float → implosion) ─────────────────────────────────
      if (prog < PH.implodeEnd + 0.01) {

        // Precompute draw positions
        const pts = particles.map(p => {
          if (pImplode > 0) {
            const tgt = p.node === 0 ? stL : stR;
            const t   = ease(pImplode);
            return { x: lerp(p.sx, tgt.x, t), y: lerp(p.sy, tgt.y, t), len: lerp(p.len, 5, t), lw: p.lw };
          }
          return { x: p.x, y: p.y, len: p.len, lw: p.lw };
        });

        // Physics update — only during pure float
        if (pImplode === 0) {
          particles.forEach(p => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            // More noise: higher random perturbation
            p.vx += (Math.random() - 0.5) * 0.30;
            p.vy += (Math.random() - 0.5) * 0.30;
            const spd = Math.hypot(p.vx, p.vy);
            if (spd > 3.8) { p.vx *= 3.8 / spd; p.vy *= 3.8 / spd; }
            // Wrap
            if (p.x < 0) p.x = W; if (p.x > W) p.x = 0;
            if (p.y < 0) p.y = H; if (p.y > H) p.y = 0;
          });
        }

        // Connection lines — fade out as particles converge
        const connA = lerp(0.15, 0, ease(pImplode));
        if (connA > 0.005) {
          ctx.strokeStyle = DOT_CLR;
          ctx.lineWidth   = 0.5;
          for (let i = 0; i < pts.length; i++) {
            for (let j = i + 1; j < pts.length; j++) {
              const d = Math.hypot(pts[i].x - pts[j].x, pts[i].y - pts[j].y);
              if (d < 120) {
                ctx.globalAlpha = (1 - d / 120) * connA;
                ctx.beginPath();
                ctx.moveTo(pts[i].x, pts[i].y);
                ctx.lineTo(pts[j].x, pts[j].y);
                ctx.stroke();
              }
            }
          }
        }

        // Slashes — 65° angle, full brightness, no glow
        // "/" goes lower-left → upper-right at 65° from horizontal
        const COS65 = Math.cos(65 * Math.PI / 180); // ≈ 0.4226
        const SIN65 = Math.sin(65 * Math.PI / 180); // ≈ 0.9063
        ctx.globalAlpha = 1;
        ctx.strokeStyle = DOT_CLR;
        ctx.lineCap     = 'round';
        pts.forEach(pt => {
          const hl = pt.len / 2;
          ctx.lineWidth = pt.lw;
          ctx.beginPath();
          ctx.moveTo(pt.x - COS65 * hl, pt.y + SIN65 * hl); // lower-left
          ctx.lineTo(pt.x + COS65 * hl, pt.y - SIN65 * hl); // upper-right
          ctx.stroke();
        });
      }

      // ── 2. Condensed nodes — solid, no glow ──────────────────────────────
      if (prog >= PH.implodeEnd * 0.8 && prog < PH.sepEnd + 0.01) {
        const fadeIn  = sub(prog, PH.implodeEnd * 0.8, PH.implodeEnd);
        const fadeOut = pSep > 0.88 ? 1 - (pSep - 0.88) / 0.12 : 1;
        const nodeA   = fadeIn * fadeOut;

        ctx.globalAlpha = nodeA;
        [[nxL, CY], [nxR, CY]].forEach(([nx, ny]) => {
          // Outer ring
          ctx.fillStyle = DOT_CLR;
          ctx.beginPath();
          ctx.arc(nx, ny, 16, 0, Math.PI * 2);
          ctx.fill();
          // Bright inner core
          ctx.fillStyle = '#e07aff';
          ctx.beginPath();
          ctx.arc(nx, ny, 9, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;
      }

      // ── 3. Collision burst — flat disc, no gradient ───────────────────────
      if (pBounce > 0 && pBounce < 1) {
        const a = (1 - ease(pBounce)) * 0.75;
        const r = lerp(12, 130, ease(pBounce));
        ctx.globalAlpha = a;
        ctx.fillStyle   = '#c055f5';
        ctx.beginPath();
        ctx.arc(CX, CY, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // ── 4. Text — 50% smaller, appears as nodes bounce apart ──────────────
      if (pSep > 0) {
        ctx.save();

        // Size to 43% of screen width (half of the 86% used elsewhere)
        ctx.font = `300 100px 'Helvetica Neue', Helvetica, Arial, sans-serif`;
        const fs = Math.round(100 * (W * 0.43) / ctx.measureText(TEXT).width);
        ctx.font = `300 ${fs}px 'Helvetica Neue', Helvetica, Arial, sans-serif`;

        // Clip grows from center outward in sync with node separation
        const half = ease(pSep) * W * 0.26;
        ctx.beginPath();
        ctx.rect(CX - half, 0, half * 2, H);
        ctx.clip();

        ctx.globalAlpha  = Math.min(1, pSep * 2.5);
        ctx.fillStyle    = '#ffffff';
        ctx.textAlign    = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(TEXT, CX, CY);
        ctx.restore();
      }

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
    window.addEventListener('resize', () => { setSize(); initParticles(); });
  </script>
</body>
</html>
