<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Constellation Slash</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #280833; overflow-x: hidden; }
    #scroll-container { height: 500vh; }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="scroll-container"></div>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const ctx    = canvas.getContext('2d');
    let W, H, CX, CY;

    function setSize() {
      W = canvas.width  = window.innerWidth;
      H = canvas.height = window.innerHeight;
      CX = W / 2; CY = H / 2;
    }
    setSize();

    const TEXT         = 'Bringing Clarity to Complexity';
    const TARGET_ANGLE = 65 * Math.PI / 180;
    const COS65        = Math.cos(TARGET_ANGLE);
    const SIN65        = Math.sin(TARGET_ANGLE);
    const SQ           = 7;           // square side in px
    const CONN_DIST    = 120;         // max constellation link distance
    const CONN_DIST_SQ = CONN_DIST * CONN_DIST;
    const ALPHA        = 0.70;        // base particle opacity

    // Colours — same palette as GridSlashAnimation
    const C_OUTLINE = '#B21EE3';
    const C_BG      = '#280833';

    // ── Utilities ─────────────────────────────────────────────────────────────
    const ease  = t => t < 0.5 ? 2*t*t : -1 + (4-2*t)*t;
    const lerp  = (a, b, t) => a + (b - a) * t;
    const clamp = (t, a = 0, b = 1) => Math.max(a, Math.min(b, t));
    const sub   = (t, a, b) => clamp((t - a) / (b - a));

    function angleLerp(a, b, t) {
      let d = b - a;
      while (d >  Math.PI) d -= 2 * Math.PI;
      while (d < -Math.PI) d += 2 * Math.PI;
      return a + d * t;
    }

    // ── Logo shapes (SVG viewBox 1176 × 991) ──────────────────────────────────
    const LOGO_SVG_W = 1176, LOGO_SVG_H = 991;
    const LOGO_SHAPES = [
      { o:{x:218.711,y:495.729}, v1:{x:319.509,y:0      }, v2:{x:-218.711,y:495.271} }, // "/" bottom-left
      { o:{x:537.792,y:495.727}, v1:{x:319.237,y:0      }, v2:{x: 218.525,y:495.272} }, // "\" bottom-right
      { o:{x:638.092,y:0      }, v1:{x:319.509,y:0      }, v2:{x: 218.711,y:495.272} }, // "\" top-right
    ];

    let logoScale, logoOX, logoOY;
    function computeLogoTransform() {
      // ~90% of screen height so plenty of particles fall inside the shapes
      logoScale = Math.min(W * 0.90 / LOGO_SVG_W, H * 0.90 / LOGO_SVG_H);
      logoOX    = (W - LOGO_SVG_W * logoScale) / 2;
      logoOY    = (H - LOGO_SVG_H * logoScale) / 2;
    }
    computeLogoTransform();

    // Returns true if canvas point (cx, cy) lies inside any logo parallelogram
    function inLogo(cx, cy) {
      const sx = (cx - logoOX) / logoScale;
      const sy = (cy - logoOY) / logoScale;
      for (const sh of LOGO_SHAPES) {
        const rx  = sx - sh.o.x, ry = sy - sh.o.y;
        const det = sh.v1.x * sh.v2.y - sh.v1.y * sh.v2.x;
        if (!det) continue;
        const s = (rx * sh.v2.y - ry * sh.v2.x) / det;
        const t = (sh.v1.x * ry - sh.v1.y * rx) / det;
        if (s >= 0 && s <= 1 && t >= 0 && t <= 1) return true;
      }
      return false;
    }

    // ── Particles ─────────────────────────────────────────────────────────────
    let particles = [];
    function initParticles() {
      particles = [];
      computeLogoTransform();

      // ~350 particles regardless of screen size
      const spacing = Math.sqrt(W * H / 350);
      const cols    = Math.round(W / spacing) + 2;
      const rows    = Math.round(H / spacing) + 2;
      const startX  = (W - (cols - 1) * spacing) / 2;
      const startY  = (H - (rows - 1) * spacing) / 2;
      const half    = Math.hypot(W, H) * 0.64; // slash half-length

      // Build grid and sort by "/" projection for R→L sweep
      const grid = [];
      for (let r = 0; r < rows; r++)
        for (let c = 0; c < cols; c++)
          grid.push({ gx: startX + c * spacing, gy: startY + r * spacing });

      const proj = g => g.gx * COS65 - g.gy * SIN65;
      grid.sort((a, b) => proj(b) - proj(a));

      const N = grid.length;
      grid.forEach((g, i) => {
        const t  = i / (N - 1);
        const tx = CX + (1 - 2 * t) * half * COS65;
        const ty = CY - (1 - 2 * t) * half * SIN65;

        particles.push({
          // Floating position — starts random, drifts slowly
          fx: Math.random() * W,
          fy: Math.random() * H,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,

          gx: g.gx, gy: g.gy, // grid anchor (settled position)
          tx, ty,              // slash target position
          delay: 1 - t,        // stagger: 1 = upper-right (aligns first)
          side:  tx >= CX ? 1 : -1,

          len:   spacing * 0.65,            // line length after morph
          lw:    Math.random() * 1.5 + 0.8, // line width after morph

          isLogo: inLogo(g.gx, g.gy), // true if grid pos is inside logo shape
        });
      });
    }
    initParticles();

    // ── Scroll ─────────────────────────────────────────────────────────────────
    let scrollProg = 0;
    window.addEventListener('scroll', () => {
      const max  = document.body.scrollHeight - window.innerHeight;
      scrollProg = Math.min(1, window.scrollY / (max * 0.85));
    });

    // Phase milestones (in eased scroll progress)
    const PH = {
      symEnd:   0.22, // floating particles → settle to grid
      logoEnd:  0.44, // logo-region squares light up white
      alignEnd: 0.70, // all squares converge to diagonal "/" + morph to lines
      holdEnd:  0.77, // brief glow hold
      splitEnd: 0.93, // panels slide apart, text reveals
    };

    let lastTS = 0;

    // ── Render ─────────────────────────────────────────────────────────────────
    function render(ts) {
      const dt = Math.min((ts - lastTS) / 16.67, 3);
      lastTS = ts;

      const prog   = ease(scrollProg);
      const pSym   = sub(prog, 0,           PH.symEnd);
      const pLogo  = sub(prog, PH.symEnd,   PH.logoEnd);
      const pAlign = sub(prog, PH.logoEnd,  PH.alignEnd);
      const pHold  = sub(prog, PH.alignEnd, PH.holdEnd);
      const pSplit = sub(prog, PH.holdEnd,  PH.splitEnd);

      // Glow blip: builds as last slashes snap into line, fades through hold
      const glowBuild = sub(pAlign, 0.78, 1.0);
      const glowFade  = 1 - ease(pHold);
      const glow      = prog < PH.alignEnd ? glowBuild : glowFade;

      // Slow floating motion to zero as sym phase kicks in
      const speedMult = clamp(1 - pSym * 1.5, 0, 1);
      if (speedMult > 0) {
        particles.forEach(p => {
          p.fx += p.vx * speedMult * dt;
          p.fy += p.vy * speedMult * dt;
          // Wrap at screen edges
          if (p.fx < -SQ)    p.fx += W + SQ * 2;
          if (p.fx > W + SQ) p.fx -= W + SQ * 2;
          if (p.fy < -SQ)    p.fy += H + SQ * 2;
          if (p.fy > H + SQ) p.fy -= H + SQ * 2;
        });
      }

      // ── Compute per-particle draw state ────────────────────────────────────
      const pts = particles.map(p => {
        let x = p.fx, y = p.fy;
        let angle = 0;
        let morph = 0; // 0 = full square, 1 = full line segment

        // Sym: lerp floating position → grid
        if (pSym > 0) {
          const t = ease(pSym);
          x = lerp(p.fx, p.gx, t);
          y = lerp(p.fy, p.gy, t);
        }

        // Logo phase: hold at grid (pSym is already 1 here)
        if (pLogo > 0 && pAlign === 0) {
          x = p.gx;
          y = p.gy;
        }

        // Align: staggered convergence to slash diagonal, square → line
        if (pAlign > 0) {
          const startPct = (1 - p.delay) * 0.38; // upper-right starts first
          const pa  = sub(pAlign, startPct, startPct + 0.62);
          const t   = ease(pa);
          x     = lerp(p.gx, p.tx, t);
          y     = lerp(p.gy, p.ty, t);
          angle = angleLerp(0, TARGET_ANGLE, ease(pa));
          morph = ease(pa);
        }

        // Split: two panels slide apart
        if (pSplit > 0) {
          x    += p.side * ease(pSplit) * W * 0.72;
          morph = 1; // stay as lines throughout split
        }

        // White highlight: logo particles fade to white during logo phase,
        //                  then fade back to purple as align phase begins
        const logoFadeIn  = p.isLogo ? ease(pLogo) : 0;
        const logoFadeOut = pAlign > 0 ? 1 - ease(pAlign) : 1;
        const whiteAmt    = logoFadeIn * logoFadeOut;

        return { x, y, angle, morph, whiteAmt, len: p.len, lw: p.lw, side: p.side };
      });

      // ── CLEAR + BACKGROUND ─────────────────────────────────────────────────
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = C_BG;
      ctx.fillRect(0, 0, W, H);

      // ── 1. Constellation lines ─────────────────────────────────────────────
      // Visible through idle + sym phases; fade as logo lights up
      const connAlpha = ALPHA * clamp(1 - ease(pLogo), 0, 1);
      if (connAlpha > 0.01 && pAlign === 0) {
        ctx.strokeStyle = C_OUTLINE;
        ctx.lineWidth   = 0.6;
        ctx.lineCap     = 'butt';
        for (let i = 0; i < pts.length; i++) {
          for (let j = i + 1; j < pts.length; j++) {
            const dx  = pts[i].x - pts[j].x;
            const dy  = pts[i].y - pts[j].y;
            const dSq = dx * dx + dy * dy;
            if (dSq >= CONN_DIST_SQ) continue;
            const dist = Math.sqrt(dSq);
            const a    = connAlpha * (1 - dist / CONN_DIST) * 0.5;
            if (a < 0.01) continue;
            ctx.globalAlpha = a;
            ctx.beginPath();
            ctx.moveTo(pts[i].x, pts[i].y);
            ctx.lineTo(pts[j].x, pts[j].y);
            ctx.stroke();
          }
        }
        ctx.globalAlpha = 1;
      }

      // ── Slash stroke colour: #B21EE3 → #ffffff at glow peak, then back ─────
      const sr       = Math.round(lerp(178, 255, glow));
      const sg       = Math.round(lerp(30,  255, glow));
      const sb       = Math.round(lerp(227, 255, glow));
      const slashClr = `rgb(${sr},${sg},${sb})`;

      // ── 2. Glow pass (drawn underneath crisp strokes) ─────────────────────
      if (glow > 0.01) {
        ctx.shadowColor = '#cc44ff';
        ctx.shadowBlur  = glow * 45;
        ctx.lineCap     = 'round';
        pts.forEach(pt => {
          if (pt.morph < 0.05) return;
          const cosA = Math.cos(pt.angle);
          const sinA = Math.sin(pt.angle);
          ctx.globalAlpha = ALPHA * pt.morph;
          ctx.strokeStyle = slashClr;
          ctx.lineWidth   = pt.lw * (1 + glow * 1.2);
          ctx.beginPath();
          ctx.moveTo(pt.x, pt.y);
          ctx.lineTo(pt.x + cosA * pt.len, pt.y - sinA * pt.len);
          ctx.stroke();
        });
        ctx.shadowBlur  = 0;
        ctx.globalAlpha = 1;
      }

      // ── 3. Particle pass ───────────────────────────────────────────────────
      ctx.lineCap = 'round';
      pts.forEach(pt => {
        const m = pt.morph;
        const w = pt.whiteAmt;

        // — Square: fades out as morph increases —
        if (m < 0.98) {
          // Outline colour: #B21EE3 → #ffffff
          const or = Math.round(lerp(178, 255, w));
          const og = Math.round(lerp(30,  255, w));
          const ob = Math.round(lerp(227, 255, w));
          // Fill colour: #280833 → #ffffff (becomes solid white block)
          const fr = Math.round(lerp(40,  255, w));
          const fg = Math.round(lerp(8,   255, w));
          const fb = Math.round(lerp(51,  255, w));

          ctx.globalAlpha = ALPHA * (1 - m);
          ctx.save();
          ctx.translate(pt.x, pt.y);
          ctx.rotate(pt.angle); // subtly rotates toward 65° as it morphs
          ctx.fillStyle   = `rgb(${fr},${fg},${fb})`;
          ctx.strokeStyle = `rgb(${or},${og},${ob})`;
          ctx.lineWidth   = 1;
          ctx.beginPath();
          ctx.rect(-SQ / 2, -SQ / 2, SQ, SQ);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
          ctx.globalAlpha = 1;
        }

        // — Line segment: fades in as morph increases —
        if (m > 0.02) {
          const cosA = Math.cos(pt.angle);
          const sinA = Math.sin(pt.angle);
          ctx.globalAlpha = ALPHA * m;
          ctx.strokeStyle = slashClr;
          ctx.lineWidth   = pt.lw;
          ctx.beginPath();
          ctx.moveTo(pt.x, pt.y);
          ctx.lineTo(pt.x + cosA * pt.len, pt.y - sinA * pt.len);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      });

      // ── 4. Text — revealed through the widening gap ────────────────────────
      if (pSplit > 0) {
        ctx.save();
        ctx.font = `300 100px 'Helvetica Neue', Helvetica, Arial, sans-serif`;
        const fs = Math.round(100 * (W * 0.43) / ctx.measureText(TEXT).width);
        ctx.font = `300 ${fs}px 'Helvetica Neue', Helvetica, Arial, sans-serif`;

        const gapHalf = ease(pSplit) * W * 0.72;
        ctx.beginPath();
        ctx.rect(CX - gapHalf, 0, gapHalf * 2, H);
        ctx.clip();

        ctx.globalAlpha  = Math.min(1, (pSplit - 0.08) / 0.42);
        ctx.fillStyle    = '#ffffff';
        ctx.textAlign    = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(TEXT, CX, CY);
        ctx.restore();
      }

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
    window.addEventListener('resize', () => { setSize(); initParticles(); });
  </script>
</body>
</html>
